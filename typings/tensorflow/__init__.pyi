from typing import Any, Iterable, Iterator, Literal, NoReturn, Sequence, overload

import numpy as np

# These types are written based on usage. The real types are often broader. If type annotation is
# inconsistent with runtime feel free to improve it. Some of these classes may be missing methods.
# You can use def __getattr__(self, name: str) -> Any: ... when you know it is incomplete with major methods
# missing. If most common methods are present it is fine to leave it out and then fill in more when errors
# are encountered.
# FloatList/Tuple ideally would be a recursive type, but mypy doesn't support it.
_FloatList = float | list[float] | list[list[float]] | list[list[list[float]]] | list[list[list[list[float]]]]
_FloatTuple = (
    float
    | tuple[float, ...]
    | tuple[tuple[float, ...], ...]
    | tuple[tuple[tuple[float, ...], ...], ...]
    | tuple[tuple[tuple[tuple[float, ...], ...], ...], ...]
)
TensorLike = Tensor | float | np.ndarray | _FloatList | _FloatTuple

class Tensor:
    @property
    def shape(self) -> TensorShape: ...
    @property
    def dtype(self) -> DType: ...
    @property
    def rank(self) -> int | None: ...
    def numpy(self) -> np.ndarray: ...
    def __abs__(self) -> Tensor: ...
    def __add__(self, other: TensorLike) -> Tensor: ...
    def __radd__(self, other: TensorLike) -> Tensor: ...
    def __sub__(self, other: TensorLike) -> Tensor: ...
    def __rsub__(self, other: TensorLike) -> Tensor: ...
    def __mul__(self, other: TensorLike) -> Tensor: ...
    def __rmul__(self, other: TensorLike) -> Tensor: ...  # type: ignore
    def __matmul__(self, other: TensorLike) -> Tensor: ...
    def __rmatmul__(self, other: TensorLike) -> Tensor: ...
    def __floordiv__(self, other: TensorLike) -> Tensor: ...
    def __rfloordiv__(self, other: TensorLike) -> Tensor: ...
    def __truediv__(self, other: TensorLike) -> Tensor: ...
    def __neg__(self) -> Tensor: ...
    def __and__(self, other: TensorLike) -> Tensor: ...
    def __rand__(self, other: TensorLike) -> Tensor: ...
    def __or__(self, other: TensorLike) -> Tensor: ...
    def __ror__(self, other: TensorLike) -> Tensor: ...
    def __eq__(self, other: TensorLike) -> Tensor: ...  # type: ignore
    def __ge__(self, other: TensorLike) -> Tensor: ...
    def __gt__(self, other: TensorLike) -> Tensor: ...
    def __bool__(self) -> NoReturn: ...
    def __getitem__(self, slice_spec: int | slice | tuple[int | slice, ...]) -> Tensor: ...
    def __getattr__(self, name: str) -> Any: ...

ShapeLike = TensorShape | Iterable[int | None]

class TensorShape:
    def __init__(self, dims: Iterable[int | None]): ...
    @property
    def rank(self) -> int: ...
    def as_list(self) -> list[int | None]: ...
    def assert_has_rank(self, rank: int) -> None: ...
    def __bool__(self) -> bool: ...
    @overload
    def __getitem__(self, key: int) -> int | None: ...
    @overload
    def __getitem__(self, key: slice) -> TensorShape: ...
    def __iter__(self) -> Iterator[int | None]: ...
    def __len__(self) -> int: ...
    def __add__(self, other: Iterable[int | None]) -> TensorShape: ...
    def __radd__(self, other: Iterable[int | None]) -> TensorShape: ...
    def __eq__(self, other: Iterable[int | None]) -> bool: ...  # type: ignore

DTypeLike = DType | str | np.dtype

class DType:
    @property
    def name(self) -> str: ...
    @property
    def is_numpy_compatible(self) -> bool: ...
    @property
    def is_bool(self) -> bool: ...
    @property
    def is_floating(self) -> bool: ...
    @property
    def is_integer(self) -> bool: ...
    @property
    def is_quantized(self) -> bool: ...
    @property
    def is_unsigned(self) -> bool: ...

class TensorSpec:
    @property
    def shape(self) -> TensorShape: ...
    @property
    def dtype(self) -> DType: ...

def clip_by_value(x: Tensor, clip_value_min: float | Tensor, clip_value_max: float | Tensor) -> Tensor: ...
def searchsorted(
    sorted_sequence: Sequence[float], values: Tensor, side: Literal["left", "right"] = "left", name: str | None = None
) -> Tensor: ...
def constant(
    value: TensorLike, dtype: DTypeLike | None = None, shape: ShapeLike | None = None, name: str | None = None
) -> Tensor: ...
def __getattr__(name: str) -> Any: ...
